JavaScript Closures In Depth: Section-level ToC

Part 1 Preparing for the journey

1 Functional thinking

1.1 First class functions

1.2 Higher order functions

1.3 Anonymous functions

1.4 Lexical scope and scope chain

1.5 Indirect invocation and function binding

1.6 Prototype chain

1.7 Summary 

2 Understanding closures 

2.1 What is closure 

2.2 Ways to create closure

2.3 Summary 

Part 2 Closure applications 

3 Deferred calls 

3.1 DOM event handlers and shared memory 

3.2 “that is this” in nested event handlers

3.3 Dealing with timers

3.4 Classical last value problem in loops

3.5 Passing arguments in callbacks

3.6 Forcing function context inside event handler

3.7 Trapping variables inside AJAX callbacks

3.8 Using closures with Node.js events

3.9 Canvas RequestAnimationFrame API and closure

3.10 Summary

4 Maintaining privacy 

4.1 Create private variables using closure

4.2 Privileged method knows the secret 

4.3 Implementing block scope

4.4 Namespaces

4.5 Summary 

5 OOP optimizations 

5.1 Extend lifetime of the constructor 

5.2 Avoid too much closure

5.3 Function constructor and closure rule 

5.4 Summary

6 Design patterns and closure 

6.1 Implement publisher subscriber pattern

 6.1.1 Groundwork

 6.1.2 Adding subscription code

 6.1.3 Classical loop problem

 6.1.4 Exceptions and async event handlers 

6.2 Module pattern

6.3 Factory pattern 

6.4 Summary 

7 Currying and Memoization

7.1 Partial application and closures

 7.1.1 Default ES5 left partial application

 7.1.2 Making right partial application

 7.1.3 Generic currying 

7.2 Memoization 

7.3 Summary 

8 Memory sharing patterns

8.1 Common memory

8.2 Independent scope chain

8.3 Summary
